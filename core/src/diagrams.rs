use std::collections::{HashMap, HashSet};
use crate::element::Element;
use crate::graph_registry::GraphRegistry;
use crate::error::ReqvireError;
use std::path::PathBuf;
use crate::utils;
use crate::info_println;
use log::debug;
use crate::relation;
use crate::element::ElementType;
use crate::element::RequirementType;
use crate::git_commands;
use crate::filesystem;
use std::path::Path;
use serde::Serialize;

/// Marker comment used to identify auto-generated diagrams
const AUTOGEN_DIAGRAM_MARKER: &str = "REQVIRE-AUTOGENERATED-DIAGRAM";

/// Default diagram direction (LR = left-to-right, TD = top-down)
pub const DEFAULT_DIAGRAM_DIRECTION: &str = "LR";

/// Model diagram report containing the complete hierarchical structure
#[derive(Debug, Serialize)]
pub struct ModelDiagramReport {
    pub folders: Vec<FolderNode>,
    pub relations: Vec<ModelRelation>,
}

/// Folder node in the model hierarchy
#[derive(Debug, Serialize)]
pub struct FolderNode {
    pub name: String,
    pub path: String,
    pub files: Vec<FileNode>,
}

/// File node in the model hierarchy
#[derive(Debug, Serialize)]
pub struct FileNode {
    pub name: String,
    pub path: String,
    pub sections: Vec<SectionNode>,
}

/// Section node in the model hierarchy
#[derive(Debug, Serialize)]
pub struct SectionNode {
    pub name: String,
    pub elements: Vec<ElementNode>,
}

/// Element node in the model diagram
#[derive(Debug, Serialize)]
pub struct ElementNode {
    pub identifier: String,
    pub name: String,
    pub element_type: String,
}

/// Relation between elements in the model
#[derive(Debug, Serialize)]
pub struct ModelRelation {
    pub source_id: String,
    pub target_id: String,
    pub target_label: String,
    pub relation_type: String,
    pub relation_label: String,
    pub arrow: String,
    pub is_external: bool,
}

/// Model diagram generator that follows the data-first pattern
pub struct ModelDiagramGenerator<'a> {
    registry: &'a GraphRegistry,
    root_element_id: Option<String>,
    forward_only: bool,
}

impl<'a> ModelDiagramGenerator<'a> {
    pub fn new(registry: &'a GraphRegistry, root_element_id: Option<&str>) -> Self {
        Self {
            registry,
            root_element_id: root_element_id.map(|s| s.to_string()),
            forward_only: false, // Default to bidirectional for backward compatibility
        }
    }

    pub fn new_with_mode(registry: &'a GraphRegistry, root_element_id: Option<&str>, forward_only: bool) -> Self {
        Self {
            registry,
            root_element_id: root_element_id.map(|s| s.to_string()),
            forward_only,
        }
    }

    /// Generate model diagram report
    pub fn generate(&self) -> Result<ModelDiagramReport, ReqvireError> {
        // Filter elements if root_element_id is provided
        let filtered_elements = if let Some(ref root_id) = self.root_element_id {
            if self.forward_only {
                collect_forward_related_elements(self.registry, root_id)
            } else {
                collect_related_elements(self.registry, root_id)
            }
        } else {
            // Include all elements
            self.registry.get_all_elements().iter().map(|e| e.identifier.clone()).collect()
        };

        // Group elements by file path, including only filtered elements
        let elements_by_file = group_elements_by_file_filtered(self.registry, &filtered_elements);

        // Group files by folder
        let files_by_folder = group_files_by_folder(&elements_by_file);

        // Build folder hierarchy
        let mut folders = Vec::new();
        let mut folder_names: Vec<&String> = files_by_folder.keys().collect();
        folder_names.sort();

        for folder_name in folder_names {
            let files = &files_by_folder[folder_name];
            let folder_path = if folder_name.is_empty() {
                "root".to_string()
            } else {
                folder_name.clone()
            };

            // Build file nodes
            let mut file_nodes = Vec::new();
            let mut sorted_files = files.clone();
            sorted_files.sort();

            for file_path_str in &sorted_files {
                if let Some(elements) = elements_by_file.get(file_path_str.as_str()) {
                    let file_name = Path::new(file_path_str.as_str())
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or(file_path_str.as_str())
                        .to_string();

                    // Group by section
                    let sections = group_by_section(elements);
                    let mut sorted_sections: Vec<&String> = sections.keys().collect();
                    sorted_sections.sort();

                    let mut section_nodes = Vec::new();
                    for section_name in sorted_sections {
                        let section_elements = &sections[section_name];

                        let mut element_nodes = Vec::new();
                        // Sort elements within section by identifier for deterministic output
                        let mut sorted_elements = section_elements.clone();
                        sorted_elements.sort_by(|a, b| a.identifier.cmp(&b.identifier));
                        for element in sorted_elements {
                            element_nodes.push(ElementNode {
                                identifier: element.identifier.clone(),
                                name: element.name.clone(),
                                element_type: element.element_type.as_str().to_string(),
                            });
                        }

                        section_nodes.push(SectionNode {
                            name: section_name.clone(),
                            elements: element_nodes,
                        });
                    }

                    file_nodes.push(FileNode {
                        name: file_name,
                        path: file_path_str.to_string(),
                        sections: section_nodes,
                    });
                }
            }

            folders.push(FolderNode {
                name: folder_path.clone(),
                path: folder_name.clone(),
                files: file_nodes,
            });
        }

        // Build relations
        let mut relations = Vec::new();
        let included_elements: HashSet<String> = filtered_elements;

        for element in self.registry.get_all_elements() {
            if !included_elements.contains(&element.identifier) {
                continue;
            }

            for relation in &element.relations {
                // Only include relations that should be shown in diagrams
                if !relation::DIAGRAM_RELATIONS.contains(&relation.relation_type.name) {
                    continue;
                }

                let (target_id, is_external) = match &relation.target.link {
                    relation::LinkType::Identifier(target_id) => {
                        if included_elements.contains(target_id) {
                            (target_id.clone(), false)
                        } else {
                            continue; // Skip relations to elements not in diagram
                        }
                    },
                    relation::LinkType::ExternalUrl(url) => (url.clone(), true),
                    relation::LinkType::InternalPath(path) => (path.to_string_lossy().to_string(), true),
                };

                if let Some(info) = relation::RELATION_TYPES.get(relation.relation_type.name) {
                    relations.push(ModelRelation {
                        source_id: element.identifier.clone(),
                        target_id,
                        target_label: relation.target.text.clone(),
                        relation_type: relation.relation_type.name.to_string(),
                        relation_label: info.label.to_string(),
                        arrow: info.arrow.to_string(),
                        is_external,
                    });
                }
            }
        }

        // Sort relations for deterministic output
        relations.sort_by(|a, b| {
            a.source_id.cmp(&b.source_id)
                .then_with(|| a.target_id.cmp(&b.target_id))
                .then_with(|| a.relation_type.cmp(&b.relation_type))
        });

        Ok(ModelDiagramReport { folders, relations })
    }

    /// Generate Mermaid diagram from model report
    pub fn generate_mermaid(&self, report: &ModelDiagramReport) -> String {
        let mut diagram = String::from(format!("```mermaid\ngraph {};\n", DEFAULT_DIAGRAM_DIRECTION));

        // Add auto-generation marker
        diagram.push_str(&format!("  %% {}\n", AUTOGEN_DIAGRAM_MARKER));

        // Define Mermaid graph styles (matching section diagrams)
        diagram.push_str("  %% Graph styling\n");
        diagram.push_str("  classDef userRequirement fill:#f9d6d6,stroke:#f55f5f,stroke-width:1px;\n");
        diagram.push_str("  classDef systemRequirement fill:#fce4e4,stroke:#e68a8a,stroke-width:1px;\n");
        diagram.push_str("  classDef verification fill:#d6f9d6,stroke:#5fd75f,stroke-width:1px;\n");
        diagram.push_str("  classDef folder fill:#f0f0f0,stroke:#666666,stroke-width:3px;\n");
        diagram.push_str("  classDef file fill:#ffffff,stroke:#999999,stroke-width:2px;\n");
        diagram.push_str("  classDef section fill:#fafafa,stroke:#aaaaaa,stroke-width:1px;\n");
        diagram.push_str("  classDef default fill:#f5f5f5,stroke:#333333,stroke-width:1px;\n\n");

        // Add folders, files, sections, and elements
        for folder in &report.folders {
            let folder_id = utils::hash_identifier(&folder.path);
            diagram.push_str(&format!("  subgraph {}[\"üìÅ {}\"]\n", folder_id, escape_label(&folder.name)));

            for file in &folder.files {
                let file_id = utils::hash_identifier(&file.path);
                diagram.push_str(&format!("    subgraph {}[\"üìÑ {}\"]\n", file_id, escape_label(&file.name)));

                for section in &file.sections {
                    let section_id = utils::hash_identifier(&format!("{}::{}", file.path, section.name));
                    diagram.push_str(&format!("      subgraph {}[\"¬ß {}\"]\n", section_id, escape_label(&section.name)));

                    for element in &section.elements {
                        let element_id = utils::hash_identifier(&element.identifier);
                        let label = escape_label(&element.name);
                        diagram.push_str(&format!("        {}[\"{}\"];\n", element_id, label));

                        // Determine element class based on type
                        let class = match element.element_type.as_str() {
                            "user-requirement" => "userRequirement",
                            "requirement" | "system-requirement" => "systemRequirement",
                            t if t.contains("verification") => "verification",
                            _ => "default",
                        };
                        diagram.push_str(&format!("        class {} {};\n", element_id, class));

                        // Add click link to element
                        diagram.push_str(&format!("        click {} \"{}\";\n", element_id, element.identifier));
                    }

                    diagram.push_str("      end\n"); // end section
                }

                diagram.push_str("    end\n"); // end file
            }

            diagram.push_str("  end\n"); // end folder
        }

        // Add relations
        let mut added_external_nodes = HashSet::new();
        for relation in &report.relations {
            let source_id = utils::hash_identifier(&relation.source_id);
            let target_id = if relation.is_external {
                let target_hash = utils::hash_identifier(&relation.target_id);
                // Only add external node definition once
                if !added_external_nodes.contains(&target_hash) {
                    let label = escape_label(&relation.target_label);
                    diagram.push_str(&format!("  {}[\"{}\"];\n", target_hash, label));
                    diagram.push_str(&format!("  class {} default;\n", target_hash));
                    added_external_nodes.insert(target_hash.clone());
                }
                target_hash
            } else {
                utils::hash_identifier(&relation.target_id)
            };

            diagram.push_str(&format!(
                "  {} {}|{}| {};\n",
                source_id,
                relation.arrow,
                relation.relation_label,
                target_id,
            ));
        }

        diagram.push_str("```");
        diagram
    }

    /// Generate JSON from model report
    pub fn generate_json(&self, report: &ModelDiagramReport) -> Result<String, ReqvireError> {
        serde_json::to_string_pretty(report)
            .map_err(|e| ReqvireError::SerializationError(e.to_string()))
    }

    /// Generate Markdown text from model report
    pub fn generate_markdown(&self, report: &ModelDiagramReport) -> String {
        let mut markdown = String::new();
        markdown.push_str("# Model Diagram Report\n\n");

        for folder in &report.folders {
            markdown.push_str(&format!("## üìÅ {}\n\n", folder.name));

            for file in &folder.files {
                markdown.push_str(&format!("### üìÑ {}\n\n", file.name));

                for section in &file.sections {
                    markdown.push_str(&format!("#### ¬ß {}\n\n", section.name));

                    for element in &section.elements {
                        markdown.push_str(&format!("- **{}** ({}): `{}`\n", element.name, element.element_type, element.identifier));
                    }

                    markdown.push_str("\n");
                }
            }
        }

        // Add relations section
        if !report.relations.is_empty() {
            markdown.push_str("## Relations\n\n");
            for relation in &report.relations {
                markdown.push_str(&format!(
                    "- `{}` {} `{}` ({})\n",
                    relation.source_id,
                    relation.relation_type,
                    if relation.is_external { &relation.target_label } else { &relation.target_id },
                    relation.relation_label
                ));
            }
        }

        markdown
    }
}

/// Generates diagrams grouped by `file_path` and `section`
pub fn generate_diagrams_by_section(
    registry: &GraphRegistry,
    diagrams_with_blobs: bool,
) -> Result<HashMap<String, String>, ReqvireError> {
    let mut diagrams: HashMap<String, String> = HashMap::new();

    // Group elements by (file_path, section)
    let mut grouped_elements: HashMap<(String, String), Vec<&Element>> = HashMap::new();

    let elements=registry.get_all_elements();

    for element in elements {
        grouped_elements
            .entry((element.file_path.clone(), element.section.clone()))
            .or_insert_with(Vec::new)
            .push(element);
    }

    // Generate diagrams for each group
    for ((file_path, section), section_elements) in grouped_elements {
        debug!("Generating diagram for file: {}, section: {}", file_path, section);

        let diagram = generate_section_diagram(registry, &section, &section_elements, &file_path, diagrams_with_blobs)?;
        let diagram_key = format!("{}::{}", file_path, section);
        diagrams.insert(diagram_key, diagram);
    }

    Ok(diagrams)
}

/// Generates a diagram for a single section
fn generate_section_diagram(
    registry: &GraphRegistry,
    _section: &str,
    elements: &[&Element],
    file_path: &str,
    diagrams_with_blobs: bool
) -> Result<String, ReqvireError> {
    // Get Git repository information for creating proper links
    let repo_root = match git_commands::get_git_root_dir() {
        Ok(root) => root,
        Err(_) => PathBuf::from(""),
    };

    let base_url = match git_commands::get_repository_base_url() {
        Ok(url) => url,
        Err(_) => String::from(""),
    };

    let commit_hash = match git_commands::get_commit_hash() {
        Ok(hash) => hash,
        Err(_) => String::from("HEAD"),
    };

    // Use default diagram direction constant
    let mut diagram = String::from(format!("```mermaid\ngraph {};\n", DEFAULT_DIAGRAM_DIRECTION));

    // Add auto-generation marker for identification
    diagram.push_str(&format!("  %% {}\n", AUTOGEN_DIAGRAM_MARKER));

    // Define Mermaid graph styles
    diagram.push_str("  %% Graph styling\n");
    diagram.push_str("  classDef userRequirement fill:#f9d6d6,stroke:#f55f5f,stroke-width:1px;\n");
    diagram.push_str("  classDef systemRequirement fill:#fce4e4,stroke:#e68a8a,stroke-width:1px;\n");
    diagram.push_str("  classDef verification fill:#d6f9d6,stroke:#5fd75f,stroke-width:1px;\n");
    diagram.push_str("  classDef default fill:#f5f5f5,stroke:#333333,stroke-width:1px;\n\n");

    let mut included_elements = HashSet::new();

    // First, add all elements in the current section
    for element in elements {
        add_element_to_diagram(
            registry,
            &mut diagram,
            element,
            &mut included_elements,
            file_path,
            diagrams_with_blobs,
            &repo_root,
            &base_url,
            &commit_hash,
        )?;
    }

    // Then, find parent elements from other sections that have Forward relations pointing to elements in this section
    let section_element_identifiers: HashSet<String> = elements.iter()
        .map(|e| e.identifier.clone())
        .collect();

    for element in registry.get_all_elements() {
        // Skip elements already in this section
        if section_element_identifiers.contains(&element.identifier) {
            continue;
        }

        // Check if this element has diagram relations pointing to any element in the current section
        let has_forward_relation_to_section = element.relations.iter().any(|relation| {
            // Only consider relations that should be shown in diagrams
            if relation::DIAGRAM_RELATIONS.contains(&relation.relation_type.name) {
                if let relation::LinkType::Identifier(target_id) = &relation.target.link {
                    return section_element_identifiers.contains(target_id);
                }
            }
            false
        });

        if has_forward_relation_to_section {
            add_element_to_diagram(
                registry,
                &mut diagram,
                element,
                &mut included_elements,
                file_path,
                diagrams_with_blobs,
                &repo_root,
                &base_url,
                &commit_hash,
            )?;
        }
    }

    diagram.push_str("```");

    Ok(diagram)
}

/// Adds an element and its relations to the diagram
fn add_element_to_diagram(
    registry: &GraphRegistry,
    diagram: &mut String,
    element: &Element,
    included_elements: &mut HashSet<String>,
    file_path: &str,
    diagrams_with_blobs: bool,  
    repo_root: &PathBuf,
    base_url: &str,
    commit_hash: &str,
) -> Result<(), ReqvireError> {

    // Convert file path to its parent directory (returns PathBuf)
    let base_dir = PathBuf::from(file_path)
        .parent()
        .map(|p| p.to_path_buf()) 
        .unwrap_or_else(|| PathBuf::from("."));
 
    // Get relative ID for local navigation
    let relative_target = utils::to_relative_identifier(
        &element.identifier.clone(),
        &base_dir,
        false
    )?;


    // Create a stable GitHub link for the element if we have the git info and diagrams should be with blobs
    let has_git_info = !base_url.is_empty() && !commit_hash.is_empty() && !repo_root.as_os_str().is_empty();
       
    let click_target = if diagrams_with_blobs && has_git_info {
        // Get repository-relative path
        let relative_id = match utils::get_relative_path(&PathBuf::from(&element.identifier)) {
            Ok(rel_path) => rel_path.to_string_lossy().to_string(),
            Err(_) => element.identifier.clone(),
        };
        
        // Create a git link for the element
        format!("{}/blob/{}/{}", base_url, commit_hash, relative_id)
    } else {
        // Fall back to the relative link for local navigation
        relative_target.clone()
    };    
        
    let element_id = utils::hash_identifier(&element.identifier);   

    if !included_elements.contains(&element.identifier) {
       included_elements.insert(element.identifier.clone());
       
       let label = element.name.replace('"', "&quot;");
       
       let class=match &element.element_type {
           ElementType::Requirement(RequirementType::User)  => "userRequirement",
           ElementType::Requirement(RequirementType::System) =>"systemRequirement",
           ElementType::Verification(_) =>"verification",
           _ => "default"
       };
           
                  
       // Add the element node
       diagram.push_str(&format!("  {}[\"{}\"];\n", element_id, label));      
       diagram.push_str(&format!("  class {} {};\n", element_id, class));
       diagram.push_str(&format!("  click {} \"{}\";\n", element_id, click_target));       
    }



    for relation in &element.relations {
        // Only render relations that should be shown in diagrams (to prevent duplicate arrows)
        if !relation::DIAGRAM_RELATIONS.contains(&relation.relation_type.name) {
            continue;
        }
        
        
        let label = relation.target.text.clone();
        let target_id = match &relation.target.link {
            relation::LinkType::Identifier(target) => {            
                
                let target_id = utils::hash_identifier(&target);               

                // Get relative ID for local navigation
                let relative_target = utils::to_relative_identifier(
                    &target,
                    &base_dir,
                    false
                )?;
                
           
                // Get a GitHub link if we have git info
                let click_target = if diagrams_with_blobs &&  has_git_info {
                    // Get repository-relative path
                    let relative_id = match utils::get_relative_path(&PathBuf::from(target)) {
                        Ok(rel_path) => rel_path.to_string_lossy().to_string(),
                        Err(_) => target.clone(),
                    };
                    
                    // Create a git link for the target element
                    format!("{}/blob/{}/{}", base_url, commit_hash, relative_id)
                } else {
                    // Fall back to the relative link for local navigation
                    relative_target.clone()
                };
                             
                
                if !included_elements.contains(target) {
                    included_elements.insert(target.clone());
                                 
                    let class = match registry.get_element(&target) {
                        Some(existing_element)=>{
                            match existing_element.element_type {
                                ElementType::Requirement(RequirementType::User)  => "userRequirement",
                                ElementType::Requirement(RequirementType::System) => "systemRequirement",
                                ElementType::Verification(_) => "verification",
                                _ => "default"
                             }
                        },
                        _ => "default"
                    };
                                                               
                    diagram.push_str(&format!("  {}[\"{}\"];\n", target_id, label));
                    diagram.push_str(&format!("  class {} {};\n", target_id, class));                    
                    diagram.push_str(&format!("  click {} \"{}\";\n", target_id, click_target));                    
                }
                target_id
            },
            relation::LinkType::ExternalUrl(url) => {
                // Always add external URLs, regardless of `included_elements`
                let target_id = utils::hash_identifier(url);
                diagram.push_str(&format!("  {}[\"{}\"];\n", target_id, label));
                diagram.push_str(&format!("  class {} {};\n", target_id,"default"));
                diagram.push_str(&format!("  click {} \"{}\";\n", target_id, url));
                
                target_id               
            },
            relation::LinkType::InternalPath(path) => {
                // Get relative ID for local navigation
                let relative_target = utils::to_relative_identifier(
                    &path.to_string_lossy().into_owned(),
                    &base_dir,
                    false
                )?;
                
           
                // Get a GitHub link if we have git info
                let click_target = if diagrams_with_blobs &&  has_git_info {
                    // Get repository-relative path
                    let relative_id = match utils::get_relative_path(&path) {
                        Ok(rel_path) => rel_path.to_string_lossy().to_string(),
                        Err(_) => path.to_string_lossy().to_string()
                    };
                    
                    // Create a git link for the target element
                    format!("{}/blob/{}/{}", base_url, commit_hash, relative_id)
                } else {
                    // Fall back to the relative link for local navigation
                    relative_target.clone()
                };
            
                // Always add internal paths, regardless of `included_elements`
                let cow = path.to_string_lossy();
                let path_str = cow.as_ref();
                let target_id = utils::hash_identifier(path_str);
                diagram.push_str(&format!("  {}[\"{}\"];\n", target_id, label));
                diagram.push_str(&format!("  class {} {};\n", target_id,"default"));
                diagram.push_str(&format!("  click {} \"{}\";\n", target_id, click_target));
                
                target_id               
            }            
        };


        if let Some(info) = relation::RELATION_TYPES.get(relation.relation_type.name) {
            // Always render as element ‚Üí target
            diagram.push_str(&format!(
                "  {} {}|{}| {};\n",
                element_id,
                info.arrow,
                info.label,
                target_id,
            ));
        }
    }

    Ok(())
}


/// Processes diagram generation for markdown files in place (without writing to output).
/// Used when the `--generate-diagrams` flag is set.
pub fn process_diagrams(
    registry: &GraphRegistry,
    diagrams_with_blobs: bool,
    ) -> Result<(), ReqvireError> {

    // Generate diagrams by section
    let diagrams = generate_diagrams_by_section(&registry, diagrams_with_blobs)?;

    // Group diagrams by file path
    let mut files_to_update: HashMap<String, Vec<(&str, &String)>> = HashMap::new();

    for (file_section_key, new_diagram) in &diagrams {
        let parts: Vec<&str> = file_section_key.split("::").collect();
        if parts.len() != 2 {
            continue; // Skip invalid entries
        }
        let file_path = parts[0];
        let section = parts[1];
    
        files_to_update
            .entry(file_path.to_string())
            .or_insert_with(Vec::new)
            .push((section, new_diagram));
    }

    // Get git root for resolving relative paths
    let git_root = match git_commands::get_git_root_dir() {
        Ok(root) => root,
        Err(_) => {
            log::error!("Not in a git repository, using current directory");
            std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."))
        }
    };

    // Process each file
    for (file_path, section_diagrams) in files_to_update {
        // Resolve file path relative to git root, not current directory
        let absolute_file_path = git_root.join(&file_path);

        // Read file content
        let mut file_content = match filesystem::read_file(&absolute_file_path) {
            Ok(content) => content,
            Err(e) => {
                log::error!("Failed to read file '{}': {}", absolute_file_path.display(), e);
                continue;
            }
        };

        // Replace diagrams for all sections in this file
        for (section, new_diagram) in section_diagrams {              
            file_content = replace_section_diagram(&file_content, section, new_diagram);
        }

        // Write updated content back if modified
        if let Err(e) = filesystem::write_file(&absolute_file_path, &file_content) {
            log::error!("Failed to write updated diagrams to '{}': {}", absolute_file_path.display(), e);
        } else {
            info_println!("Updated diagrams in '{}'", file_path);
        }
    }

    Ok(())
}

/// Replaces the old diagram in a specific section of a markdown file.
///
/// - `content`: The original file content.
/// - `section`: The section name where the diagram should be replaced.
/// - `new_diagram`: The newly generated Mermaid diagram.
///
/// Returns the modified file content as a `String`.
fn replace_section_diagram(content: &str, section: &str, new_diagram: &str) -> String {
    let section_header = format!("## {}", section);
    let mermaid_block_start = "```mermaid";
    let mermaid_block_end = "```";

    let mut new_lines = Vec::new();
    let mut lines = content.lines().peekable();
    while let Some(line) = lines.next() {
        if line.trim() == section_header {
            // Found the target section header.
            new_lines.push(line.to_string());

            // Skip any blank lines immediately after the header.
            while let Some(&next_line) = lines.peek() {
                if next_line.trim().is_empty() {
                    lines.next();
                } else {
                    break;
                }
            }

            // Check if the next non-empty line starts a Mermaid block
            if let Some(&next_line) = lines.peek() {
                if next_line.trim().starts_with(mermaid_block_start) {
                    // Found a mermaid block - collect it to check for autogen marker
                    let mut mermaid_lines = Vec::new();
                    mermaid_lines.push(lines.next().unwrap().to_string()); // mermaid start

                    let mut has_autogen_marker = false;
                    while let Some(l) = lines.next() {
                        if l.contains(AUTOGEN_DIAGRAM_MARKER) {
                            has_autogen_marker = true;
                        }
                        mermaid_lines.push(l.to_string());
                        if l.trim().starts_with(mermaid_block_end) {
                            break;
                        }
                    }

                    // Only replace diagrams with the autogenerated marker
                    if has_autogen_marker {
                        new_lines.push(new_diagram.to_string());
                    } else {
                        // Preserve user-created diagrams
                        new_lines.extend(mermaid_lines);
                    }
                } else {
                    // No mermaid block exists, insert the new diagram
                    new_lines.push(new_diagram.to_string());
                }
            } else {
                // No content after section header, insert the new diagram
                new_lines.push(new_diagram.to_string());
            }
        } else {
            new_lines.push(line.to_string());
        }
    }
    new_lines.join("\n")
}

/// Remove all generated mermaid diagrams from markdown files
/// Follows the same pattern as process_diagrams but removes instead of replacing
pub fn remove_diagrams(registry: &GraphRegistry) -> Result<(), ReqvireError> {
    // Group elements by (file_path, section) - same as in generate_diagrams_by_section
    let mut grouped_elements: HashMap<(String, String), Vec<&Element>> = HashMap::new();

    let elements = registry.get_all_elements();

    for element in elements {
        grouped_elements
            .entry((element.file_path.clone(), element.section.clone()))
            .or_insert_with(Vec::new)
            .push(element);
    }

    // Group sections by file path - same pattern as in process_diagrams
    let mut files_to_update: HashMap<String, Vec<String>> = HashMap::new();

    for (file_path, section) in grouped_elements.keys() {
        files_to_update
            .entry(file_path.clone())
            .or_insert_with(Vec::new)
            .push(section.clone());
    }

    // Get git root for resolving relative paths
    let git_root = match git_commands::get_git_root_dir() {
        Ok(root) => root,
        Err(_) => {
            log::error!("Not in a git repository, using current directory");
            std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."))
        }
    };

    // Process each file
    for (file_path, sections) in files_to_update {
        // Resolve file path relative to git root, not current directory
        let absolute_file_path = git_root.join(&file_path);

        // Read file content
        let mut file_content = match filesystem::read_file(&absolute_file_path) {
            Ok(content) => content,
            Err(e) => {
                log::error!("Failed to read file '{}': {}", absolute_file_path.display(), e);
                continue;
            }
        };

        // Remove diagrams for all sections in this file
        for section in sections {
            file_content = remove_section_diagram(&file_content, &section);
        }

        // Write updated content back if modified
        if let Err(e) = filesystem::write_file(&absolute_file_path, &file_content) {
            log::error!("Failed to write updated file '{}': {}", absolute_file_path.display(), e);
        } else {
            println!("Removed diagrams from '{}'", file_path);
        }
    }

    Ok(())
}


/// Removes the diagram from a specific section of a markdown file.
/// Similar to replace_section_diagram but only removes without adding a new diagram.
fn remove_section_diagram(content: &str, section: &str) -> String {
    let section_header = format!("## {}", section);
    let mermaid_block_start = "```mermaid";
    let mermaid_block_end = "```";

    let mut new_lines = Vec::new();
    let mut lines = content.lines().peekable();

    while let Some(line) = lines.next() {
        if line.trim() == section_header {
            // Found the target section header.
            new_lines.push(line.to_string());
            // Skip any blank lines immediately after the header.
            while let Some(&next_line) = lines.peek() {
                if next_line.trim().is_empty() {
                    lines.next();
                } else {
                    break;
                }
            }
            // If the next non-empty line starts a Mermaid block, skip it.
            if let Some(&next_line) = lines.peek() {
                if next_line.trim().starts_with(mermaid_block_start) {
                    // Skip the mermaid block: first skip the start marker.
                    lines.next();
                    // Then skip lines until the end marker is found.
                    while let Some(l) = lines.next() {
                        if l.trim().starts_with(mermaid_block_end) {
                            break;
                        }
                    }
                }
            }
            // Continue with the rest of the file.
        } else {
            new_lines.push(line.to_string());
        }
    }

    new_lines.join("\n")
}

/// Generates a complete model diagram with containment hierarchy using Mermaid subgraphs
/// Shows folders > files > sections > elements with relations
///
/// # Arguments
/// * `registry` - The graph registry containing all elements
/// * `root_element_id` - Optional element ID to generate diagram from. If None, generates full model.
///                        If Some, generates diagram starting from that element and its related elements.
pub fn generate_model_diagram(registry: &GraphRegistry, root_element_id: Option<&str>) -> Result<String, ReqvireError> {
    let generator = ModelDiagramGenerator::new(registry, root_element_id);
    let report = generator.generate()?;
    Ok(generator.generate_mermaid(&report))
}

/// Generates a model diagram with optional filtering and output format selection
///
/// # Arguments
/// * `registry` - The graph registry containing all elements
/// * `root_element_id` - Optional element ID to filter from. If provided with forward_only=true, only includes forward-reachable elements
/// * `forward_only` - If true and root_element_id is provided, only traverses forward relations (derive, satisfiedBy, verifiedBy, trace)
/// * `json_output` - If true, returns JSON; otherwise returns markdown with embedded Mermaid diagram
pub fn generate_model_report(
    registry: &GraphRegistry,
    root_element_id: Option<&str>,
    forward_only: bool,
    json_output: bool,
) -> Result<String, ReqvireError> {
    let generator = ModelDiagramGenerator::new_with_mode(registry, root_element_id, forward_only);
    let report = generator.generate()?;

    if json_output {
        generator.generate_json(&report)
    } else {
        // Return markdown with embedded Mermaid diagram
        let mut output = generator.generate_markdown(&report);
        output.push_str("\n\n");
        output.push_str(&generator.generate_mermaid(&report));
        Ok(output)
    }
}

/// Collects all elements related to a root element by traversing the graph
/// This includes the root element and all elements it has relations to/from
fn collect_related_elements(registry: &GraphRegistry, root_id: &str) -> HashSet<String> {
    let mut result = HashSet::new();
    let mut to_visit = vec![root_id.to_string()];

    while let Some(current_id) = to_visit.pop() {
        if result.contains(&current_id) {
            continue;
        }
        result.insert(current_id.clone());

        if let Some(element) = registry.get_element(&current_id) {
            // Add all elements this element relates to
            for relation in &element.relations {
                if let relation::LinkType::Identifier(target_id) = &relation.target.link {
                    if !result.contains(target_id) {
                        to_visit.push(target_id.clone());
                    }
                }
            }

            // Also find elements that relate to this element
            for other_element in registry.get_all_elements() {
                if other_element.identifier == current_id {
                    continue;
                }

                for relation in &other_element.relations {
                    if let relation::LinkType::Identifier(target_id) = &relation.target.link {
                        if target_id == &current_id && !result.contains(&other_element.identifier) {
                            to_visit.push(other_element.identifier.clone());
                        }
                    }
                }
            }
        }
    }

    result
}

/// Collects all elements reachable from a root element by traversing only forward relations
/// This includes the root element and all elements reachable via DIAGRAM_RELATIONS (derive, satisfiedBy, verifiedBy, trace)
/// Does NOT traverse backward - only follows outgoing relations from each element
fn collect_forward_related_elements(registry: &GraphRegistry, root_id: &str) -> HashSet<String> {
    let mut result = HashSet::new();
    let mut to_visit = vec![root_id.to_string()];

    while let Some(current_id) = to_visit.pop() {
        if result.contains(&current_id) {
            continue;
        }
        result.insert(current_id.clone());

        if let Some(element) = registry.get_element(&current_id) {
            // Only add elements this element relates to (forward relations only)
            for relation in &element.relations {
                // Only follow forward relations shown in diagrams
                if !relation::DIAGRAM_RELATIONS.contains(&relation.relation_type.name) {
                    continue;
                }

                if let relation::LinkType::Identifier(target_id) = &relation.target.link {
                    if !result.contains(target_id) {
                        to_visit.push(target_id.clone());
                    }
                }
            }
            // NOTE: We do NOT traverse backward - only outgoing relations from each element
        }
    }

    result
}

/// Helper to group elements by file path, filtering to only include specified element IDs
fn group_elements_by_file_filtered<'a>(registry: &'a GraphRegistry, filter: &HashSet<String>) -> HashMap<String, Vec<&'a Element>> {
    let mut result: HashMap<String, Vec<&'a Element>> = HashMap::new();
    for element in registry.get_all_elements() {
        if filter.contains(&element.identifier) {
            result.entry(element.file_path.clone())
                .or_insert_with(Vec::new)
                .push(element);
        }
    }
    result
}

/// Helper to group files by folder
fn group_files_by_folder(elements_by_file: &HashMap<String, Vec<&Element>>) -> HashMap<String, Vec<String>> {
    let mut result: HashMap<String, Vec<String>> = HashMap::new();
    for file_path in elements_by_file.keys() {
        let folder = Path::new(file_path)
            .parent()
            .and_then(|p| p.to_str())
            .unwrap_or("")
            .to_string();
        result.entry(folder)
            .or_insert_with(Vec::new)
            .push(file_path.clone());
    }
    result
}

/// Helper to group elements by section
fn group_by_section<'a>(elements: &[&'a Element]) -> HashMap<String, Vec<&'a Element>> {
    let mut result: HashMap<String, Vec<&Element>> = HashMap::new();
    for element in elements {
        let section = if element.section.is_empty() {
            "(no section)".to_string()
        } else {
            element.section.clone()
        };
        result.entry(section)
            .or_insert_with(Vec::new)
            .push(element);
    }
    result
}

/// Escape special characters in labels for Mermaid
fn escape_label(text: &str) -> String {
    text.replace('"', "&quot;")
        .replace('[', "&#91;")
        .replace(']', "&#93;")
        .replace('(', "&#40;")
        .replace(')', "&#41;")
}
