use crate::element::{Element, SubSection, ElementType, RequirementType};
use crate::relation::Relation;
use crate::error::ReqvireError;
use crate::utils;
use log::debug;
use std::collections::HashSet;
use std::path::PathBuf;

/// Removes only auto-generated mermaid diagrams from content
/// Preserves user-created diagrams by checking for the REQVIRE-AUTOGENERATED-DIAGRAM marker
fn remove_generated_diagrams(content: &str) -> String {
    let mut result = String::new();
    let mut lines = content.lines();

    while let Some(line) = lines.next() {
        if line.trim().starts_with("```mermaid") {
            // Collect the entire mermaid block to check if it's auto-generated
            let mut block_lines = vec![line];
            let mut is_auto_generated = false;

            // Read until the closing ```
            while let Some(block_line) = lines.next() {
                block_lines.push(block_line);

                if block_line.contains("REQVIRE-AUTOGENERATED-DIAGRAM") {
                    is_auto_generated = true;
                }

                if block_line.trim() == "```" {
                    break;
                }
            }

            // Only include the block if it's NOT auto-generated (preserve user diagrams)
            if !is_auto_generated {
                for block_line in block_lines {
                    result.push_str(block_line);
                    result.push('\n');
                }
            }
        } else {
            result.push_str(line);
            result.push('\n');
        }
    }

    result
}

/// Parses a markdown document and extracts elements with metadata and relations.
/// Returns: (elements, errors, page_content, sections)
pub fn parse_elements(
    file: &str,
    content: &str,
    file_path: &PathBuf,
    user_requirements_root_folder: &Option<PathBuf>,
) -> (Vec<Element>, Vec<ReqvireError>, String, Vec<(String, String, usize)>) {
    let mut elements = Vec::new();
    let mut current_element: Option<Element> = None;
    let mut errors = Vec::new();
    let mut seen_identifiers = HashSet::new();
    let mut skip_current_element = false;
    let mut seen_subsections = HashSet::new();
    let mut in_details_block = false; 


    let mut current_subsection = SubSection::Other("".to_string());
    let mut current_section_name = "Requirements";

    // Content tracking variables
    let mut page_content = String::new();
    let mut current_section_content = String::new();
    let mut found_first_section = false;
    let mut sections = Vec::new();

    // Section order tracking
    let mut section_element_counter: std::collections::HashMap<String, usize> = std::collections::HashMap::new();
    let mut section_order_counter = 0;

    // Initialize the default section order
    section_element_counter.insert(current_section_name.to_string(), 0);

    for (line_num, line) in content.lines().enumerate() {
        let trimmed = line.trim();


        if in_details_block {
            if !skip_current_element {
                if let Some(element) = &mut current_element {
                    element.add_content(&format!("{}\n", line));
                }
            }
        
            if trimmed.starts_with("</details>") {
                in_details_block = false;
            }
        
            continue; // Skip any further processing while in <details>        

        }else if trimmed == "---" {
            current_subsection = SubSection::Other("".to_string());

        } else if trimmed.starts_with("## ") {
            // Save previous section content if this isn't the first section
            if found_first_section {
                let cleaned_content = remove_generated_diagrams(&current_section_content);
                // Always save the section, even if it has no content, to preserve order
                sections.push((current_section_name.to_string(), cleaned_content.trim().to_string(), section_order_counter));
                // Increment section order after saving the previous section
                section_order_counter += 1;
            } else {
                // First ## section encountered - check if default section has elements
                let default_section_count = section_element_counter.get(current_section_name).unwrap_or(&0);
                if *default_section_count > 0 {
                    // Save the default "Requirements" section with order 0 only if it has elements
                    let cleaned_content = remove_generated_diagrams(&current_section_content);
                    sections.push((current_section_name.to_string(), cleaned_content.trim().to_string(), 0));
                    // Next section will have order 1
                    section_order_counter = 1;
                } else {
                    // No elements in default section, first ## section gets order 0
                    section_order_counter = 0;
                }
            }

            // Start new section
            current_section_name = trimmed[3..].trim();
            current_section_content.clear();
            found_first_section = true;
            current_subsection = SubSection::Other("".to_string());

            // Reset element counter for new section
            section_element_counter.insert(current_section_name.to_string(), 0);

        } else if trimmed.starts_with("### ") {
            current_subsection = SubSection::Requirement;

            if let Some(mut element) = current_element.take() {
                if !skip_current_element {
                    element.freeze_content();
                    elements.push(element);
                }
            }

            skip_current_element = false;
            seen_subsections.clear();

            let element_name = trimmed[4..].trim().to_string();

            match file_path.parent() {
                Some(file_folder) => {
                    let identifier = format!("{}#{}", file, element_name);

                    match utils::normalize_identifier(
                        &identifier,
                        &file_folder.to_path_buf()
                    ) {
                        Ok(identifier) => {
                        
                            let relative_file = match utils::get_relative_path(&file_path) {
                                Ok(path) => path,
                                Err(err) => {                                   
                                    debug!("Error: {}", &err);
                                    skip_current_element = true;                                
                                    errors.push(err); 
                                    continue;
                                }
                            };
                            if seen_identifiers.contains(&identifier) {
                                let msg = format!(
                                    "'{}' already seen (file: {}, line {})",
                                    element_name,
                                    relative_file.display(),
                                    line_num + 1
                                );
                                errors.push(ReqvireError::DuplicateElement(msg.clone()));
                                debug!("Error: {}", msg);
                                skip_current_element = true;
                            } else {
                                seen_identifiers.insert(identifier.clone());

                                let element_type = if utils::is_in_user_requirements_root(&file_folder.to_path_buf(), user_requirements_root_folder) {
                                    ElementType::Requirement(RequirementType::User)
                                } else {
                                    ElementType::Requirement(RequirementType::System)
                                };

                                let mut new_element = Element::new(
                                    &element_name,
                                    &identifier,
                                    &relative_file.to_string_lossy(),
                                    &current_section_name,
                                    Some(element_type),
                                );

                                // Set section order index
                                let current_index = section_element_counter.get(current_section_name).unwrap_or(&0);
                                new_element.section_order_index = *current_index;
                                section_element_counter.insert(current_section_name.to_string(), current_index + 1);

                                current_element = Some(new_element);
                                debug!("Found element: {}", element_name);
                            }
                        }
                        Err(e) => {
                            let msg = format!(
                                "Failed to normalize identifier for '{}': {} (file: {}, line {})",
                                element_name,
                                e,
                                file_path.display(),
                                line_num + 1
                            );
                            errors.push(ReqvireError::InvalidIdentifier(msg.clone()));
                            debug!("Error: {}", msg);
                            skip_current_element = true;
                        }
                    }
                }
                None => {
                    let msg = format!(
                        "Failed to normalize identifier for '{}': {} (file: {}, line {})",
                        element_name,
                        "File folder not accessible.",
                        file_path.display(),
                        line_num + 1
                    );
                    errors.push(ReqvireError::InvalidIdentifier(msg.clone()));
                    debug!("Error: {}", msg);
                    skip_current_element = true;
                }
            }

        } else if trimmed.starts_with("#####") && current_element.is_some() && current_subsection != SubSection::Details && !skip_current_element {
            // Level 5+ headers are only allowed inside Details subsection
            let msg = format!(
                "Invalid header level in element '{}': Level 5+ headers (#####+) can only appear inside '#### Details' subsection (file: {}, line {})",
                current_element.as_ref().unwrap().name,
                file_path.display(),
                line_num + 1
            );
            errors.push(ReqvireError::InvalidMarkdownStructure(msg.clone()));
            debug!("Error: {}", msg);

        } else if trimmed.starts_with("#### ") && current_element.is_some() {
            let subsection = SubSection::from_str(&trimmed[5..].trim());

            if !skip_current_element {
                if seen_subsections.contains(&subsection) {
                    let msg = format!(
                        "Duplicate subsection '{}' in element '{}' (file: {}, line {})",
                        subsection.name(),
                        current_element.as_ref().unwrap().name,
                        file_path.display(),
                        line_num + 1
                    );
                    errors.push(ReqvireError::DuplicateSubsection(msg.clone()));
                    debug!("Error: {}", msg);
                } else {
                    seen_subsections.insert(subsection.clone());
                }
            }

            // If transitioning to Details subsection, add the header to content
            if subsection == SubSection::Details && !skip_current_element {
                if let Some(element) = &mut current_element {
                    element.add_content("\n#### Details\n");
                }
            }

            current_subsection = subsection;

        } else if (current_subsection == SubSection::Requirement || current_subsection == SubSection::Details)
            && !skip_current_element
        {
            if let Some(element) = &mut current_element {
                if trimmed.starts_with("<details") {
                    in_details_block = true;
                }
        
                element.add_content(&format!("{}\n", line));

            }

        } else if in_details_block && !skip_current_element {
            // Still inside <details> block under 'Details' subsection
            if let Some(element) = &mut current_element {
                element.add_content(&format!("{}\n", line));
            }

        } else if current_subsection == SubSection::Metadata && !skip_current_element {
            if trimmed.is_empty() {
                continue;
            }
            if let Some(element) = &mut current_element {
                if let Some((key, value)) = utils::parse_metadata_line(trimmed) {
                    element.metadata.insert(key.clone(), value.clone());

                    if key.eq_ignore_ascii_case("type") {
                        element.set_type_from_metadata();
                    }
                } else {
                    let msg = format!(
                        "Element '{}' has invalid metadata format: '{}' (file: {}, line {})",
                        element.name, trimmed, file, line_num + 1
                    );
                    errors.push(ReqvireError::InvalidMetadataFormat(msg.clone()));
                    debug!("Error: {}", msg);
                    current_subsection = SubSection::Other("".to_string());
                }
            }

        } else if current_subsection == SubSection::Relations && !skip_current_element {
            if let Some(element) = &mut current_element {
                if trimmed.starts_with("* ") {
                    match utils::parse_relation_line(trimmed) {
                        Ok((relation_type, (text, link))) => {
                            let final_link = if link.starts_with('#') {
                                format!("{}{}", file, link)
                            } else {
                                link
                            };

                            match file_path.parent() {
                                Some(file_folder) => {
                                    match utils::normalize_identifier(
                                        &final_link,
                                        &file_folder.to_path_buf()
                                    ) {
                                        Ok(normalized_target) => {
                                            match Relation::new(&relation_type, text, &normalized_target) {
                                                Ok(relation) => {
                                                    element.add_relation(relation);
                                                }
                                                Err(_) => {
                                                    let msg = format!(
                                                        "'{}' in element '{}': (file: {}, line {})",
                                                        relation_type, element.name, file, line_num + 1
                                                    );
                                                    errors.push(ReqvireError::UnsupportedRelationType(msg.clone()));
                                                    debug!("Error: {}", msg);
                                                }
                                            }
                                        }
                                        Err(e) => {
                                            let msg = format!(
                                                "Failed to normalize identifier for '{}': {} (file: {}, line {})",
                                                element.name, e, file, line_num + 1
                                            );
                                            errors.push(ReqvireError::InvalidIdentifier(msg.clone()));
                                            debug!("Error: {}", msg);
                                        }
                                    }
                                }
                                None => {
                                    let msg = format!(
                                        "Failed to normalize identifier for '{}': {} (file: {}, line {})",
                                        trimmed,
                                        "File folder not accessible.",
                                        file_path.display(),
                                        line_num + 1
                                    );
                                    errors.push(ReqvireError::InvalidIdentifier(msg.clone()));
                                    debug!("Error: {}", msg);
                                }
                            }
                        }
                        Err(_) => {
                            let msg = format!(
                                "Element '{}' has invalid relation format: '{}'. (file: {}, line {})",
                                element.name, trimmed, file, line_num + 1
                            );
                            errors.push(ReqvireError::UnsupportedRelationType(msg.clone()));
                            debug!("Error: {}", msg);
                        }
                    }
                } else if trimmed.is_empty() {
                    // Ignore
                } else {
                    let msg = format!(
                        "Element '{}' has invalid relations format: '{}' (file: {}, line {})",
                        element.name, trimmed, file, line_num + 1
                    );
                    errors.push(ReqvireError::InvalidRelationFormat(msg.clone()));
                    debug!("Error: {}", msg);
                    current_subsection = SubSection::Other("".to_string());
                }
            }

        } else if matches!(current_subsection, SubSection::Other(_)) {
            // Accumulate content outside of elements
            if !found_first_section {
                // Page content: everything before first section
                page_content.push_str(line);
                page_content.push('\n');
            } else {
                // Section content: everything after section header but before first element
                current_section_content.push_str(line);
                current_section_content.push('\n');
            }
        }
    }

    // Final element
    if let Some(mut element) = current_element.take() {
        if !skip_current_element {
            element.freeze_content();
            elements.push(element);
        }
    }

    // Save final section content
    if found_first_section {
        let cleaned_content = remove_generated_diagrams(&current_section_content);
        // Always save the final section, even if it has no content, to preserve order
        sections.push((current_section_name.to_string(), cleaned_content.trim().to_string(), section_order_counter));
    }

    // Clean page content
    let cleaned_page_content = remove_generated_diagrams(&page_content);

    (elements, errors, cleaned_page_content.trim().to_string(), sections)
}


